#!/usr/bin/env python

import os
import sys
import dbus
from optparse import OptionParser
from signal import signal, SIGINT, SIG_DFL


signal(SIGINT, SIG_DFL)

DEFAULT_TREE = "cpu"
CGROUPS_PATH = "/sys/fs/cgroup"


class drug():
    def __init__(self, **kwargs):
        for k in kwargs:
            setattr(self, k, kwargs[k])


style = drug(**dict(
        default    = "\033[m",
        # styles
        bold       = "\033[1m",
        underline  = "\033[4m",
        blink      = "\033[5m",
        reverse    = "\033[7m",
        concealed  = "\033[8m",
        # font colors
        black      = "\033[30m",
        red        = "\033[31m",
        green      = "\033[32m",
        yellow     = "\033[33m",
        blue       = "\033[34m",
        magenta    = "\033[35m",
        cyan       = "\033[36m",
        white      = "\033[37m",
        # background colors
        on_black   = "\033[40m",
        on_red     = "\033[41m",
        on_green   = "\033[42m",
        on_yellow  = "\033[43m",
        on_blue    = "\033[44m",
        on_magenta = "\033[45m",
        on_cyan    = "\033[46m",
        on_white   = "\033[47m"))



class Session:

    def __init__(self):
        self.bus = dbus.SystemBus()
        self.sets = {
            'config':self.set_config,
            'active':self.set_active,
            }
        self.gets = {
            'config':self.get_config,
            'desc':self.get_desc,
            'systemflags':self.get_systemflags,
            'activelistlength':self.get_activelistlength,
            }

    def init_system(self):
        if hasattr(self, 'system'): return
        self.system = self.bus.get_object(
            'org.quamquam.ulatencyd',
            '/org/quamquam/ulatencyd/System')

    def init_user(self):
        if hasattr(self, 'user'): return
        self.user = self.bus.get_object(
            'org.quamquam.ulatencyd',
            '/org/quamquam/ulatencyd/User')

    def config_list(self):
        self.init_system()
        system = dbus.Interface(self.system, 'org.quamquam.ulatencyd.System')
        try: return list(map(unicode, system.listSchedulerConfigs()))
        except dbus.exceptions.DBusException as e:
            print(e)
            sys.exit(2)

    def set(self, key, *value):
        if key not in self.sets:
            print("error: key '{0}' not available".format(key))
            sys.exit(1)
        return self.sets[key](*value)

    def set_config(self, config=None):
        configs = self.config_list()
        if config is None: return ",".join(configs)
        if config not in configs:
            print("error: config '{0}' not available".format(config))
            sys.exit(1)
        system = dbus.Interface(self.system, 'org.quamquam.ulatencyd.System')
        try: return system.setSchedulerConfig(config)
        except dbus.exceptions.DBusException as e:
            print(e)
            sys.exit(2)

    def set_active(self, pid=None):
        if pid is None:
            print("error: no pid given")
            sys.exit(1)
        self.init_user()
        user = dbus.Interface(self.user, 'org.quamquam.ulatencyd.User')
        try: return user.setActive(pid)
        except dbus.exceptions.DBusException as e:
            print(e)
            sys.exit(2)


    def get(self, key, *value):
        if key not in self.gets:
            print("error: key '{0}' not available".format(key))
            sys.exit(1)
        return self.gets[key](*value)

    def get_config(self):
        self.init_system()
        properties=dbus.Interface(self.system,'org.freedesktop.DBus.Properties')
        try:
            return unicode(properties.Get(
                'org.quamquam.ulatencyd.System', 'config'))
        except dbus.exceptions.DBusException as e:
            print(e)
            sys.exit(2)

    def get_desc(self, config=None):
        configs = self.config_list()
        if config is None: return ",".join(configs)
        if config not in configs:
            print("error: config '{0}' not available".format(config))
            sys.exit(1)
        system = dbus.Interface(self.system, 'org.quamquam.ulatencyd.System')
        try: return system.getSchedulerConfigDescription(config)
        except dbus.exceptions.DBusException as e:
            print(e)
            sys.exit(2)

    def get_systemflags(self):
        self.init_system()
        system = dbus.Interface(self.system, 'org.quamquam.ulatencyd.System')
        try:
            return list(map(unicode, system.listSystemFlags()))
        except dbus.exceptions.DBusException as e:
            print(e)
            sys.exit(2)

    def get_activelistlength(self):
        self.init_user()
        properties = dbus.Interface(self.user,'org.freedesktop.DBus.Properties')
        try:
            return unicode(properties.Get(
                'org.quamquam.ulatencyd.User', 'activeList'))
        except dbus.exceptions.DBusException as e:
            print(e)
            sys.exit(2)



class Tree(object):
    """Displays a cgroup tree"""

    boxes = {
      True: drug(
        start     = u"\u2500\u252c\u00bb",
        branch    = u"\u251c",
        last      = u"\u2514",
        end       = u"\u00ab",
        subtree   = u"\u2502",
        file      = u" " ),
      False: drug(
        start     = u"# ",
        branch    = u"+-",
        last      = u"+-",
        end       = u" #",
        subtree   = u"|",
        file      = u" " ),
    }

    def __init__(self, tree=DEFAULT_TREE, processes=True, show_all=True,
                 utf = True, color = False):
        self.tree = tree
        self.processes = processes
        self.show_all = show_all
        self.utf = utf
        if color:
            self.color = drug(
                process = u"{0.yellow}{1}{0.default} {2}",
                subtree = u"{0.bold}{0.black}{1}{0.default}",
                tree    = u"{0.bold}{0.black}{1}{2}{3}{0.default}{0.green}" +
                          u"{5}{0.bold}{0.black}{4}{0.default}",
                file    = u"{0.bold}{0.black}{1}{2}{3}{0.default}{4}" )
        else:
            self.color = drug(
                process = u"{1} {2}",
                subtree = u"{1}",
                tree    = u"{1}{2}{3}{5}{4}",
                file    = u"{1}{2}{3}{4}" )
        path = self.get_path()
        if path:
            self.cache = drug(children = [], path = path,
                name = os.path.basename(os.path.abspath(path)))
        else:
            print "error: tree does not exist"
            sys.exit(1)

    def get_process(self, pid):
        try:
            fp = file(os.path.join("/proc", pid, "status"))
        except OSError:
            return None
        name = u""
        for line in fp.readlines():
            chunks = line.split(":\t")
            if chunks[0] == 'Name':
                name = chunks[1].strip()
            if chunks[0] == 'Tgid':
                tgid = chunks[1].strip()
            if chunks[0] == 'Pid':
                pid = chunks[1].strip()
        fp.close()
        if not self.show_all and pid != tgid:
          return None
        return pid, name

    def generate(self, dir):
        tree = drug(children = [], path = dir,
            name = os.path.basename(os.path.abspath(dir)))
        files = []
        if self.processes and os.path.exists(os.path.join(dir, "tasks")):
            fp = file(os.path.join(dir, "tasks"), "r")
            for line in fp.readlines():
                proc = self.get_process(line.strip())
                if proc:
                    files.append(proc)
            fp.close()
        for x in os.listdir(dir):
            if os.path.isdir(dir + os.sep + x):
                files.append((None, x))

        for pid, fname in files:
            path = os.path.join(dir, fname)
            if os.path.isdir(path):
                tree.children.append(self.generate(path))
            else:
                tree.children.append(drug(pid = pid, name = fname, path = path))
        return tree

    def get_path(self):
        path = u"{0}/{1}".format(CGROUPS_PATH, self.tree)
        if not os.path.exists(path):
            return None
        return path


    def update(self):
        path = self.get_path()
        if not path: return
        tree = self.generate(path)
        self.cache = tree
        return tree

    def display(self):
        path = u"{0}/{1}".format(CGROUPS_PATH, self.tree)
        print path
        if not os.path.exists(path):
            print "error: tree does not exist"
            sys.exit(1)

        def rec(branch, padding, islast=None):
            if hasattr(branch, 'pid'):
                process = self.color.process.format(
                    style, branch.pid, branch.name)
                print self.color.file.format(style, padding,
                    islast or self.boxes[self.utf].branch,
                    self.boxes[self.utf].file, process)
                return
            print self.color.tree.format(style, padding,
                islast or self.boxes[self.utf].branch,
                self.boxes[self.utf].start,
                self.boxes[self.utf].end,
                branch.name)
            count = 0
            for child in branch.children:
                count += 1
                last = None
                p = padding
                if count == len(branch.children):
                    last = self.boxes[self.utf].last
                    if os.path.isdir(branch.path):
                        if islast:
                            p = p + u" "
                        else:
                            p = p + self.boxes[self.utf].subtree
                    p = p + u" "
                else:
                    if islast:
                        p = p + u" "
                    else:
                        p = p + self.boxes[self.utf].subtree
                    if os.path.isdir(branch.path):
                        p = p + u" "
                rec(child, p, last)

        rec(self.generate(path), u"", self.boxes[self.utf].last)



class Gui:

    def __init__(self):
        pass

    def run(self):
        return 0


class QtGui(Gui):

    def __init__(self):
        from PyQt4.Qt import Qt, QApplication, QSystemTrayIcon,\
                             QIcon, QPixmap, QMenu, QMainWindow,\
                             QTreeWidget, QTreeWidgetItem
        self.QTreeWidgetItem = QTreeWidgetItem
        self.app = app = QApplication(sys.argv)
        self.session = Session()
        self.tree = Tree()
        icon = QIcon(QPixmap(self.get_logo()))
        app.trayicon = QSystemTrayIcon(icon, app)
        app.trayicon.show()
        self.window = win = QMainWindow()

        win.ui = ui = drug(
            treeview = QTreeWidget(win),
        )
        win.setCentralWidget(ui.treeview)
        ui.treeview.setHeaderLabels(["pid", "process"])

        self.cur = self.session.get_config()
        configs = self.session.config_list()

        self.app.menu = QMenu()
        menu = self.app.menu.addMenu("set config")
        self.config_action = {}
        def connect(con):
            return lambda: self.switch_config(con)
        for config in configs:
            self.config_action[config] = c = menu.addAction(config)
            c.setCheckable(True)
            c.setChecked(self.cur == config)
            c.setToolTip(unicode(self.session.get_desc(config)))
            c.triggered.connect(connect(config))
        menu = self.app.menu
        menu.addSeparator()
        quit = menu.addAction("Quit")

        self.update_tree()
        app.trayicon.activated.connect(self.toggle_window)
        app.trayicon.setContextMenu(menu)
        quit.triggered.connect(app.quit)
        print "loaded."

    def run(self):
        return self.app.exec_()

    def toggle_window(self, reason):
        if reason != self.app.trayicon.Context:
            self.window.setVisible(not self.window.isVisible())

    def update_tree(self):
        QTreeWidgetItem = self.QTreeWidgetItem
        tree = self.tree.update()

        def rec(branch, parent):
            pid = u""
            if hasattr(branch, 'pid'):
                pid = branch.pid
            item = QTreeWidgetItem(parent, [pid, branch.name])
            if hasattr(branch, 'children'):
                for child in branch.children:
                    if hasattr(child, 'children'):
                        rec(child, item)
                for child in branch.children:
                    if not hasattr(child, 'children'):
                        rec(child, item)

        rec(tree, self.window.ui.treeview)

    def switch_config(self, new):
        self.config_action[self.cur].setChecked(False)
        self.config_action[new].setChecked(True)
        cmd = " {0} set config {1}".format(sys.argv[0], new)
        if os.system("gtksudo" + cmd) == 32512:
            print os.system("kdesudo" + cmd)
        self.cur = new

    def get_logo(self):
        header = ["16 16 5 1"]
        chars = ["#","x","o","."]
        color = ["black",
            "gray25",
            "gray50",
            "white"]
        background = [
            "                ",
            "      xxxx      ",
            "    xx####xx    ",
            "   x##xxxx##x   ",
            "  x#xx    xx#x  ",
            "  x#x      x#x  ",
            " x#x        x#x ",
            " x#x        x#x ",
            " x#x        x#x ",
            " x#x        x#x ",
            "  x#x      x#x  ",
            "  x#xx    xx#x  ",
            "   x##xxxx##x   ",
            "    xx####xx    ",
            "      xxxx      ",
            "                "]
        foreground = [
            "      ",
            "oo  oo",
            "o.  .o",
            "o....o",
            "oooo.o",
            "   o.o",
            "   ooo"]
        color = ["  c None"] + [char+" c "+col for char,col in zip(chars,color)]
        for y, line in enumerate(foreground):
            for x, char in enumerate(line):
                if char != " ":
                    s = background[y+4]
                    background[y+4] = s[:x+5] + char + s[x+6:]
        return header + color + background



def main():
    parser = OptionParser( usage = "usage: %prog [options] [key [value]]" )
    parser.add_option("--config-list", dest="list", action="store_true",
        default=False, help="list system configs")
    parser.add_option("-s", "--set", dest="set", action="store_true",
        default=False, help="set key value pair")
    parser.add_option("-g", "--get", dest="get", action="store_true",
        default=False, help="get value by key")
    parser.add_option("--gui", dest="gui", action="store_true",
        default=False, help="enable gui")
    parser.add_option("--no-utf", dest="utf", action="store_false",
        default=True, help="disables utf8 for tree view")
    parser.add_option("--no-color", dest="color", action="store_false",
        default=True, help="disables color")
    parser.add_option("--all", dest="all", action="store_true",
        default=False, help="show complete tree")
    parser.add_option("--no-processes", dest="processes", action="store_false",
        default=True, help="hide all processes")


    options, args = parser.parse_args()

    if options.gui:
        sys.exit(QtGui().run())

    if options.list:
        print("\n".join(Session().config_list()))
        sys.exit(0)

    if options.set or args and args[0] == 'set':
        if len(args[1:]):
            print(Session().set(*args[1:]))
            sys.exit(0)
        else: print(",".join(Session().sets.keys()))

    if options.get or args and args[0] == 'get':
        if len(args[1:]):
            print(Session().get(*args[1:]))
            sys.exit(0)
        else: print(",".join(Session().gets.keys()))

    if not args or args[0] == 'tree':
        kwargs = dict(utf = options.utf, color = options.color,
            show_all = options.all, processes = options.processes)
        if len(args) >= 1:
            tree = Tree(tree=args[1], **kwargs)
        else:
            tree = Tree(**kwargs)
        tree.display()


if __name__ == "__main__":
    main()
